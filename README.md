## 工厂模式学习

> UMl类结构地址

[工厂模式UML结构图](https://github.com/snowriverL/factory/tree/master/src/main/resources/uml)

### 简单工厂模式

    简单工厂模式（Simple Factory Pattern）是指由一个工厂对象决定创建出哪一种产品类
    的实例，但它不属于 GOF，23 种设计模式
    
> 缺点：工厂类的职责相对过重，不易于扩展过于复杂的产品结构。

### 工厂方法模式

    工厂方法模式（Fatory Method Pattern）是指定义一个创建对象的接口，但让实现这个
    接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法
    模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符
    合开闭原则
    
>* 工厂方法适用于以下场景：

    1、创建对象需要大量重复的代码。
    2、客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
    3、一个类通过其子类来指定创建哪个对象。
   
>* 工厂方法也有缺点：

    1、类的个数容易过多，增加复杂度。
    2、增加了系统的抽象性和理解难度
    
### 抽象工厂模式

    抽象工厂模式（Abastract Factory Pattern）是指提供一个创建一系列相关或相互依赖
    对象的接口，无须指定他们具体的类  
    
    客户端（应用层）不依赖于产品类实例如何被创
    建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对
    象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从
    而使客户端不依赖于具体实现。
    
>* 缺点：

    1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂
    的接口。
    2、增加了系统的抽象性和理解难度。
    
    但在实际应用中，我们千万不能犯强迫症甚至有洁癖。在实际需求中产品等级结构升级
    是非常正常的一件事情。我们可以根据实际情况，只要不是频繁升级，可以不遵循开闭
    原则。代码每半年升级一次或者每年升级一次又有何不可呢？      